#include "Nodes/FroxFindContoursNode.h"
#include "Shared.h"
#include "FroxTypes.h"

#include "Frox/Frox/ComputeFlow.h"
#include "Frox/Frox/FindContoursComputeNode.h"
#include "Frox/Frox/CenterOfContourComputeNode.h"
#include "Frox/Frox/RadiusOfContourComputeNode.h"

#define LOCTEXT_NAMESPACE "UFroxFindContoursNode"

frox::EFindContoursMode FindContoursModeToFroxMode(EFroxFindContoursMode Mode)
{
	switch (Mode)
	{
	case EFroxFindContoursMode::External:
		return frox::EFindContoursMode::External;
	case EFroxFindContoursMode::List:
		return frox::EFindContoursMode::List;
	case EFroxFindContoursMode::CComp:
		return frox::EFindContoursMode::CComp;
	case EFroxFindContoursMode::Tree:
		return frox::EFindContoursMode::Tree;
	case EFroxFindContoursMode::FloodFill:
		return frox::EFindContoursMode::FloodFill;
	default:
		assert(false);
	}

	return frox::EFindContoursMode::Tree;
}

frox::EContourApproximationMode FindContoursMethodToFroxMethod(EFroxContourApproximationMode Method)
{
	switch (Method)
	{
	case EFroxContourApproximationMode::ChainApproxNone:
		return frox::EContourApproximationMode::ChainApproxNone;
	case EFroxContourApproximationMode::ChainApproxSimple:
		return frox::EContourApproximationMode::ChainApproxSimple;
	case EFroxContourApproximationMode::ChainApproxTC89_L1:
		return frox::EContourApproximationMode::ChainApproxTC89_L1;
	case EFroxContourApproximationMode::ChainApproxTC89_KCOS:
		return frox::EContourApproximationMode::ChainApproxTC89_KCOS;
	default:
		assert(false);
	}

	return frox::EContourApproximationMode::ChainApproxSimple;
}

/// FindContours
#if WITH_EDITORONLY_DATA
void UFroxFindContoursNode::AllocateDefaultPins()
{
	Super::AllocateDefaultPins();

	UEdGraphPin* In = CreatePin(EGPD_Input, UFroxNodeBase::PC_Frame, TEXT("In"));

	UEdGraphPin* OffsetPin = CreatePin(EGPD_Input, UFroxNodeBase::PC_Property, FFroxTypeDefinition::IntType, TEXT("Offset"));
	OffsetPin->DefaultValue = TEXT("0, 0");
	OffsetPin->bAdvancedView = true;
	OffsetPin->AutogeneratedDefaultValue = TEXT("0, 0");

	UEdGraphPin* Contours = CreatePin(EGPD_Output, UFroxNodeBase::PC_Data, TEXT("Contours"));
	UEdGraphPin* Hierarchy = CreatePin(EGPD_Output, UFroxNodeBase::PC_Data, TEXT("Hierarchy"));

	if (ENodeAdvancedPins::NoPins == AdvancedPinDisplay)
	{
		AdvancedPinDisplay = ENodeAdvancedPins::Hidden;
	}
}
#endif

frox::ComputeNode* UFroxFindContoursNode::CreateFroxNode(frox::ComputeFlow* Flow) const
{
	check(Flow != nullptr);

	auto FroxNode = Flow->CreateNode<frox::FindContoursComputeNode>();
	check(FroxNode != nullptr);

	FroxNode->SetMode(FindContoursModeToFroxMode(Mode));
	FroxNode->SetMethod(FindContoursMethodToFroxMethod(Method));

	return FroxNode;
}

/// CenterOfContour
#if WITH_EDITORONLY_DATA
void UFroxCenterOfContourNode::AllocateDefaultPins()
{
	Super::AllocateDefaultPins();

	UEdGraphPin* In = CreatePin(EGPD_Input, UFroxNodeBase::PC_Data, TEXT("In"));
	UEdGraphPin* Out = CreatePin(EGPD_Output, UFroxNodeBase::PC_Data, TEXT("Out"));
}
#endif

frox::ComputeNode* UFroxCenterOfContourNode::CreateFroxNode(frox::ComputeFlow* Flow) const
{
	check(Flow != nullptr);

	auto FroxNode = Flow->CreateNode<frox::CenterOfContourComputeNode>();
	check(FroxNode != nullptr);

	return FroxNode;
}

/// RadiusOfContour
#if WITH_EDITORONLY_DATA
void UFroxRadiusOfContourNode::AllocateDefaultPins()
{
	Super::AllocateDefaultPins();

	UEdGraphPin* In = CreatePin(EGPD_Input, UFroxNodeBase::PC_Data, TEXT("In"));
	UEdGraphPin* Out = CreatePin(EGPD_Output, UFroxNodeBase::PC_Data, TEXT("Out"));
}
#endif

frox::ComputeNode* UFroxRadiusOfContourNode::CreateFroxNode(frox::ComputeFlow* Flow) const
{
	check(Flow != nullptr);

	auto FroxNode = Flow->CreateNode<frox::RadiusOfContourComputeNode>();
	check(FroxNode != nullptr);

	return FroxNode;
}

#undef LOCTEXT_NAMESPACE